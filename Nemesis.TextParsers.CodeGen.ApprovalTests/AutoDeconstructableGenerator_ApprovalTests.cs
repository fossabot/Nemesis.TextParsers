extern alias original;
using System.Collections.Generic;
using System.Linq;

using ApprovalTests;
using ApprovalTests.Reporters;
using ApprovalTests.Writers;

using NUnit.Framework;

using System.IO;
using ApprovalTests.Core;

using System;

using System.Reflection;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nemesis.TextParsers.CodeGen.Deconstructable;


namespace Nemesis.TextParsers.CodeGen.ApprovalTests
{
    [TestFixture]
    public class AutoDeconstructableGeneratorApprovalTests
    {
        private static IEnumerable<TestCaseData> ApprovalTestCases() =>
            EndToEndCases().Select((tc, i) => tc.SetName($"Approval_{i + 1:00}"));

        [TestCaseSource(nameof(ApprovalTestCases)), Explicit]
        [UseReporter(typeof(IgnoreNewLineReporter))
        ]
        public void EndToEndTests_ApprovalTests(string source, string _)
        {
            var compilation = CreateCompilation(source);

            var generatedTrees = GetGeneratedTreesOnly(compilation);

            var actual = ScrubGeneratorComments(generatedTrees.Single());

            Approvals.Verify(WriterFactory.CreateTextWriter(actual, "cs"));
        }

        private static readonly Regex _headerPattern = new Regex(@"/\*\s*<auto-generated>   .+?   </auto-generated>\s*\*/", RegexOptions.Singleline | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled);
        private static readonly Regex _generatorPattern = new Regex(@""".*Generator""\s*,\s*""([0-9.]+)""", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled);

        public static string ScrubGeneratorComments(string text)
        {
            text = _generatorPattern.Replace(text, "META");
            text = _headerPattern.Replace(text, "HEAD");

            return text;
        }

        public static GeneratorDriver CreateDriver(Compilation c, params ISourceGenerator[] generators)
            => CSharpGeneratorDriver.Create(generators, parseOptions: (CSharpParseOptions)c.SyntaxTrees.First().Options);

        public static Compilation RunGenerators(Compilation c, out IReadOnlyList<Diagnostic> diagnostics, params ISourceGenerator[] generators)
        {
            CreateDriver(c, generators).RunGeneratorsAndUpdateCompilation(c, out var compilation, out var diagnosticsArray);
            diagnostics = diagnosticsArray;
            return compilation;
        }
        private static IReadOnlyList<string> GetGeneratedTreesOnly(Compilation compilation, int requiredCardinality = 1)
        {
            var newComp = RunGenerators(compilation, out var diagnostics, new AutoDeconstructableGenerator());
            Assert.That(diagnostics, Is.Empty);

            SyntaxTree attributeTree = null;
            foreach (var tree in newComp.SyntaxTrees)
            {
                var attributeDeclaration = tree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .FirstOrDefault(cds => string.Equals(cds.Identifier.ValueText, "AutoDeconstructableAttribute", StringComparison.Ordinal));
                if (attributeDeclaration != null)
                {
                    attributeTree = tree;
                    break;
                }
            }
            Assert.That(attributeTree, Is.Not.Null, "Auto attribute not found among generated trees");

            var toRemove = compilation.SyntaxTrees.Append(attributeTree);

            var generatedTrees = newComp.RemoveSyntaxTrees(toRemove).SyntaxTrees.ToList();
            Assert.That(generatedTrees, Has.Count.EqualTo(requiredCardinality));

            return generatedTrees.Select(tree =>
                ((CompilationUnitSyntax)tree.GetRoot())
                .ToFullString()).ToList();
        }

        public static Compilation CreateCompilation(string source, OutputKind outputKind = OutputKind.DynamicallyLinkedLibrary)
        {
            var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location) ?? throw new InvalidOperationException("The location of the .NET assemblies cannot be retrieved");

            return CSharpCompilation.Create("compilation",
                new[] { CSharpSyntaxTree.ParseText(source, new CSharpParseOptions(LanguageVersion.Latest)) },
                new[]
                {
                    MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Runtime.dll")),
                    MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(original::Nemesis.TextParsers.ITransformer).GetTypeInfo()
                        .Assembly.Location),
                },
                new CSharpCompilationOptions(outputKind));
        }


        private static IEnumerable<TestCaseData> EndToEndCases() => new (string source, string expectedCode)[]
        {
            (@"public record RecordPoint2d(double X, double Y) { }

               [Auto.AutoDeconstructable]
               [DeconstructableSettings(',', '∅', '\\', '[', ']')]
               public partial record RecordPoint3d(double X, double Y, double Z): RecordPoint2d(X, Y) 
               {
                   public double Magnitude { get; init; } //will NOT be subject to deconstruction
               }", @"HEAD
using System;
using Nemesis.TextParsers.Parsers;
using Nemesis.TextParsers.Utils;

namespace Nemesis.TextParsers.CodeGen.Tests
{
    [Transformer(typeof(RecordPoint3dTransformer))]
    public partial record RecordPoint3d 
    {
#if DEBUG
        internal void DebuggerHook() { System.Diagnostics.Debugger.Launch(); }
#endif
    }

    [System.CodeDom.Compiler.GeneratedCode(META)]
    [System.Runtime.CompilerServices.CompilerGenerated]
    sealed class RecordPoint3dTransformer : TransformerBase<RecordPoint3d>
    {
        private readonly ITransformer<double> _transformer_X = TextTransformer.Default.GetTransformer<double>();
        private readonly ITransformer<double> _transformer_Y = TextTransformer.Default.GetTransformer<double>();
        private readonly ITransformer<double> _transformer_Z = TextTransformer.Default.GetTransformer<double>();
        private const int ARITY = 3;


        private readonly TupleHelper _helper = new TupleHelper(',', '∅', '\\', '[', ']');

        public override RecordPoint3d GetEmpty() => new RecordPoint3d(_transformer_X.GetEmpty(), _transformer_Y.GetEmpty(), _transformer_Z.GetEmpty());
        protected override RecordPoint3d ParseCore(in ReadOnlySpan<char> input)
        {
            var enumerator = _helper.ParseStart(input, ARITY);
            var t1 = _helper.ParseElement(ref enumerator, _transformer_X);

            _helper.ParseNext(ref enumerator, 2);
            var t2 = _helper.ParseElement(ref enumerator, _transformer_Y);

            _helper.ParseNext(ref enumerator, 3);
            var t3 = _helper.ParseElement(ref enumerator, _transformer_Z);

            _helper.ParseEnd(ref enumerator, ARITY);
            return new RecordPoint3d(t1, t2, t3);
        }

        public override string Format(RecordPoint3d element)
        {
            Span<char> initialBuffer = stackalloc char[32];
            var accumulator = new ValueSequenceBuilder<char>(initialBuffer);
            try
            {
                 _helper.StartFormat(ref accumulator);
                 var (X, Y, Z) = element;
                _helper.FormatElement(_transformer_X, X, ref accumulator);

                _helper.AddDelimiter(ref accumulator);
                _helper.FormatElement(_transformer_Y, Y, ref accumulator);

                _helper.AddDelimiter(ref accumulator);
                _helper.FormatElement(_transformer_Z, Z, ref accumulator);

                _helper.EndFormat(ref accumulator);
                return accumulator.AsSpan().ToString();
            }
            finally { accumulator.Dispose(); }
        }
    }
}"),



            (@"[Auto.AutoDeconstructable]
               [DeconstructableSettings(';', '∅', '\\', '(', ')')]
               public readonly partial struct Point3d
               {
                   public double X { get; } public double Y { get; } public double Z { get; }
                   public Point3d(double x, double y, double z) { X = x; Y = y; Z = z; }

                   public void Deconstruct(out double x, out System.Double y, out double z) { x = X; y = Y; z = Z; }
               }", @"HEAD
using System;
using Nemesis.TextParsers.Parsers;
using Nemesis.TextParsers.Utils;

namespace Nemesis.TextParsers.CodeGen.Tests
{
    [Transformer(typeof(Point3dTransformer))]
    public readonly partial struct Point3d 
    {
#if DEBUG
        internal void DebuggerHook() { System.Diagnostics.Debugger.Launch(); }
#endif
    }

    [System.CodeDom.Compiler.GeneratedCode(META)]
    [System.Runtime.CompilerServices.CompilerGenerated]
    sealed class Point3dTransformer : TransformerBase<Point3d>
    {
        private readonly ITransformer<double> _transformer_x = TextTransformer.Default.GetTransformer<double>();
        private readonly ITransformer<double> _transformer_y = TextTransformer.Default.GetTransformer<double>();
        private readonly ITransformer<double> _transformer_z = TextTransformer.Default.GetTransformer<double>();
        private const int ARITY = 3;


        private readonly TupleHelper _helper = new TupleHelper(';', '∅', '\\', '(', ')');

        public override Point3d GetEmpty() => new Point3d(_transformer_x.GetEmpty(), _transformer_y.GetEmpty(), _transformer_z.GetEmpty());
        protected override Point3d ParseCore(in ReadOnlySpan<char> input)
        {
            var enumerator = _helper.ParseStart(input, ARITY);
            var t1 = _helper.ParseElement(ref enumerator, _transformer_x);

            _helper.ParseNext(ref enumerator, 2);
            var t2 = _helper.ParseElement(ref enumerator, _transformer_y);

            _helper.ParseNext(ref enumerator, 3);
            var t3 = _helper.ParseElement(ref enumerator, _transformer_z);

            _helper.ParseEnd(ref enumerator, ARITY);
            return new Point3d(t1, t2, t3);
        }

        public override string Format(Point3d element)
        {
            Span<char> initialBuffer = stackalloc char[32];
            var accumulator = new ValueSequenceBuilder<char>(initialBuffer);
            try
            {
                 _helper.StartFormat(ref accumulator);
                 var (x, y, z) = element;
                _helper.FormatElement(_transformer_x, x, ref accumulator);

                _helper.AddDelimiter(ref accumulator);
                _helper.FormatElement(_transformer_y, y, ref accumulator);

                _helper.AddDelimiter(ref accumulator);
                _helper.FormatElement(_transformer_z, z, ref accumulator);

                _helper.EndFormat(ref accumulator);
                return accumulator.AsSpan().ToString();
            }
            finally { accumulator.Dispose(); }
        }
    }
}")
        }
           .Select((t, i) => new TestCaseData($@"using Nemesis.TextParsers.Settings; namespace Nemesis.TextParsers.CodeGen.Tests {{ {t.source} }}", t.expectedCode)
               .SetName($"E2E_{i + 1:00}"));
    }

    public class IgnoreNewLineReporter : IReporterWithApprovalPower
    {
        public void Report(string approvedFilePath, string receivedFilePath)
        {
            static string Normalize(string text) => text.Replace("\r\n", "\n").Replace("\r", "\n");

            FileAssert.Exists(approvedFilePath);
            FileAssert.Exists(receivedFilePath);

            var left = Normalize(File.ReadAllText(approvedFilePath));
            var right = Normalize(File.ReadAllText(receivedFilePath));

            Assert.That(left, Is.EqualTo(right));
        }

        public bool ApprovedWhenReported() => true;

        /*public static void VerifyText(string text, string fileExtensionWithoutDot = "cs", Func<string, string> scrubber = null)
               {
                   if (scrubber != null)
                       text = scrubber(text);

                   text = text.Replace("\r\n", "\n").Replace("\r", "\n");

                   Approvals.Verify(WriterFactory.CreateTextWriter(text, fileExtensionWithoutDot));
               }*/
    }
}
